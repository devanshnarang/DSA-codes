/*deque(double ended queue)-removal and addition of elements can be donefrom any of the 2 ends */// #include<iostream>// #include<deque>// #include<queue>// using namespace std;// int main(){//     deque<int> dq;//     dq.push_back(10);//     dq.push_back(20);//     dq.push_back(30);//     dq.push_front(5);//     while (not dq.empty())//     {//         cout<<dq.front()<<" ";//         dq.pop_front();//     }    //     return 0;// } // #include<iostream>// #include<deque>// #include<vector>// using namespace std;// void max_window(vector<int> &arr,int k){//     deque<int> dq;//     vector<int> res;//     for (int i = 0; i < k; i++)//     {//         while (not dq.empty() and arr[dq.back()]<arr[i])//         {//             dq.pop_back();//         }//         dq.push_back(i); //     }//     res.push_back(arr[dq.front]);//     for (int i = k; i < arr.size(); i++)//     {//         int curr=arr[i];//         if (dq.front()==i-k)//         {//             dq.pop_front();//         }//         while (not dq.empty() and arr[dq.back()]<arr[i])//         {//             dq.pop_back();//         }//         dq.push_back(i); //         res.push_back(arr[dq.front]); //     }        // }// int main(){
//     return 0;// }//implement queue using staack data structures/*2 types of soln push efficient -push-O(1) pop can be badpop efficient-O(1),push can be bad*///queue using stack -push efficient// #include<iostream>// #include<stack>// using namespace std;// class Queue{//     stack<int> st;//     public://     Queue(){}//     void push(x){//         //queue.enqueue()//         this->st.push(x);//     }//     void pop(){//         if (this->st.empty())//         {//             return;//         }        //         stack<int> tmp;//         while (st.size()>1)//         {//             tmp.push(st.top());//             st.pop();//         }//         this->st.pop();//         while (not tmp.empty())//         {//             this->st.push(tmp.top());//             tmp.pop();//         }//     }//     bool empty(){//         return this->st.empty();//     }//     int front(){//         if (this->st.empty())//         {//             return;//         }        //         stack<int> tmp;//         while (st.size()>1)//         {//             tmp.push(st.top());//             int res=st.top();//         }//         this->st.pop();//         while (not tmp.empty())//         {//             this->st.push(tmp.top());//             tmp.pop();//         }//         return st.top();//     }    // };// int main(){//     return 0;// }//pop efficient// #include<iostream>// #include<stack>// using namespace std;// class Queue{//     stack<int> st;//     public://     Queue(){}//     void push(x){//         //queue.enqueue()//         stack<int> temp;//         while (not this->st.empty())//         {//             temp.push(this->st.top());//             this->st.pop();//         }//         this->st.push(x);//         while (not temp.empty())//         {//             this->st.push(temp.top());//             temp.pop();//         } //     }//     void pop(){//         if (this->st.empty())//         {//             return;//         }//         this->st.pop();//     }//     bool empty(){//         return this->st.empty();//     }//     int front(){//         if (this->st.empty())//         {//             return;//         }        //         return this->st.top(); //     }    // };// int main(){//     return 0;// }//stacks using ques also of 2 types push and pop efficient//circular queues#include<iostream>#include<vector>class Queue{    int front;    int back;    vector<int> v;    int cs=0;    public:    Queue(int n){        v.resize(n);        this->ts=n;        this->back=n-1;        this->front=0;        this->cs=0;    }    void enqueue(int data){        if (isFull())        {            return;        }        this->back=(this->back+1)%this->ts;        this->v[this->back]=data;        this->cs++;    }    void dequeue(){        if (isEmpty())        {            return;        }        this->front=(this->front+1)%this->ts;        this->cs--;    }    bool isEmpty(){        return this->cs==0;    }    bool isFull(){        return this->cs==this->ts;    }};using namespace std;int main(){    return 0;}